# 스택(Stack)

- 선입후출
- 입구와 출구가 동일 -> 박스 쌓기, 또는 프링글스 통
- 리스트 자료형을 이용 (오른쪽이 입출구)
- stack = []
- append(), pop() 메서드 이용
- print(stack[::-1]) <- 스택의 최상단 원소부터 출력
- print(stack) <- 스택의 최하단 원소부터 출력



# 큐(Queue)

- 선입선출

- 오른쪽이 입구, 왼쪽이 출구 -> 입구와 출구가 모두 뚫려있는 터널 형태, 대기열
- deque 라이브러리를 이용 (list 자료형은 시간복잡도가 더 높아서 비효율적으로 동작)
- queue = deque()
- append(), popleft() 메서드 이용
- print(queue) <- 먼저 들어온 순서대로 출력
- queue.reverse()
- print(queue) <- 나중에 들어온 원소부터 출력



 # 재귀 함수(Recursive Function)

- 자기 자신을 다시 호출하는 함수
- 재귀 함수의 종료 조건을 반드시 명시해야 함. 그러지 않으면 함수가 무한히 호출됨.
- 재귀 함수를 이용하면 마치 스택에 데이터를 넣었다 꺼내는 것과 마찬가지로, 각각의 함수에 대한 정보가 실제로 스택 프레임에 담겨서 차례대로 호출되었다가 가장 마지막에 호출된 함수부터 차례대로 종료됨.
- 모든 재귀 함수는 반복문을 이용하여 동일한 기능을 구현할 수 있는데, 재귀 함수가 반복문보다 유리한 경우도 있고 불리한 경우도 있으므로, 특정 문제를 만났을 때 더 좋은 방법을 고려하여 문제를 풀어야 한다.
- 컴퓨터가 함수를 재귀적으로 호출하면 실제로는 컴퓨터 메모리 내부의 스택 프레임에 차곡차곡 쌓인다. 그래서 스택을 사용해야 할 때 구현상 스택 자료구조를 사용하지 않고 그냥 재귀 함수를 이용하는 경우가 많다. DFS를 간결한 코드로 작성하기 위해 단순히 재귀 함수를 이용해서 DFS를 구현하곤 한다.



# DFS(Depth-First Search)

- 깊이 우선 탐색
- 스택 자료구조 혹은 재귀 함수를 이용
- 알고리즘
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
  3. 더이상 2번의 과정을 수행할 수 없을 때까지 반복한다.
- 각 노드가 연결된 정보를 2차원 리스트로 표현
- 각 노드가 방문된 정보를 1차원 리스트로 표현
- 노드의 개수가 n개면 원소가 (n+1)개인 리스트 객체를 만들어 주고 0 인덱스는 사용하지 않는다.



# BFS(Breadth-First Search)

- 너비 우선 탐색
- 큐 자료구조를 이용
- 알고리즘
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
  2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리한다.
  3. 더이상 2번의 과정을 수행할 수 없을 때까지 반복한다.
- 각 노드가 연결된 정보를 2차원 리스트로 표현
- 각 노드가 방문된 정보를 1차원 리스트로 표현
- 노드의 개수가 n개면 원소가 (n+1)개인 리스트 객체를 만들어 주고 0 인덱스는 사용하지 않는다.
- 간선의 비용이 모두 같을 때 최단거리를 탐색하기 위해 사용할 수 있는 알고리즘

